# 
# Kernel CVE check class
# Copyright (c) Cybertrust Japan Co., Ltd.
#
# Authors:
#  Masami Ichikawa <masami.ichikawa@miraclelinux.com>
#
# SPDX-License-Identifier: MIT
#

inherit cve-check

KERNEL_CVE_CHECK_CIP_KERNEL_SEC_DIR ??= ""

# TODO: Change to "cip" when CIP Project releases linux-6.1.y-cip.
KERNEL_CVE_CHECK_REMOTE_TARGET = "stable"

# Show ignored CVEs
KERNEL_CVE_CHECK_INCLUDE_IGNORE ??= "1"

# Remote branch name. bitbake detects it from kernel-src by default.
KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_REPO ??= ""
KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_AUTODETECT ??= "1"

KERNEL_CVE_CHECK_RESULT_FILE = "kernel_cve_check_result.json"

# It requires an initial value to ignore kernel cve check if PN is not kernel
KERNEL_CVE_CHECK_TASK_ORDER = ""
KERNEL_PN ??= 'linux-cip'

def remove_remote(d, workdir):
    """
    Remove needless remotes from remotes.yml.
    """
    import yaml

    remotes_path = os.path.join(workdir, 'remotes.yml')

    with open(remotes_path) as f:
        content = yaml.safe_load(f)

    remote = d.getVar('KERNEL_CVE_CHECK_REMOTE_TARGET')
    with open(remotes_path, 'w') as f:
        yaml.dump({remote: content[remote]}, f, default_flow_style=False)

def kernel_cve_check_update_cip_kernel_sec(d):
    """
    Update cip-kernel-sec repository.
    """
    import os
    from bb.fetch2 import runfetchcmd

    kernel_cve_check_dir = d.getVar('DL_DIR')
    d.setVar('KERNEL_CVE_CHECK_CIP_KERNEL_SEC_DIR', kernel_cve_check_dir)

    cip_kernel_sec_path = os.path.join(kernel_cve_check_dir, 'cip-kernel-sec')
    git_uri = 'https://gitlab.com/cip-project/cip-kernel/cip-kernel-sec.git'

    if not os.path.isdir(kernel_cve_check_dir):
        os.mkdir(kernel_cve_check_dir)

    if not os.path.isdir(cip_kernel_sec_path):
        # first run
        runfetchcmd("git clone %s cip-kernel-sec" % git_uri, d,  workdir=kernel_cve_check_dir)
        remove_remote(d, os.path.join(cip_kernel_sec_path, "conf"))
        runfetchcmd("git update-index --skip-worktree conf/remotes.yml", d, workdir=cip_kernel_sec_path)
    else:
        runfetchcmd("git pull", d, workdir=cip_kernel_sec_path)

    return True

def get_issue_list(cip_kernel_sec_path):
    """
    Get issue list registered to cip-kernel-sec.
    """
    import glob
    glob_param = cip_kernel_sec_path + "/issues/CVE-*.yml"

    return [os.path.basename(name)[:-4] for name in glob.glob(glob_param)]

def kernel_cve_check_run(d):
    """
    Check cves by cip-kernel-sec
    """
    from bb.fetch2 import runfetchcmd
    import requests
    import bb.process

    kernel_path = d.getVar("S")
    linux_cip_ver = d.getVar('LINUX_CIP_VERSION')
    cip_kernel_sec_path = f'{d.getVar("KERNEL_CVE_CHECK_CIP_KERNEL_SEC_DIR")}/cip-kernel-sec'
    include_ignore = d.getVar('KERNEL_CVE_CHECK_INCLUDE_IGNORE')
    remote_repo_name = d.getVar('KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_REPO')
    remote_repo_autodetect = d.getVar('KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_AUTODETECT')
    remote_target = d.getVar('KERNEL_CVE_CHECK_REMOTE_TARGET')

    opt_ignore = "--include-ignored" if include_ignore == "1" else ""

    # Try to get remote name from kernel repository
    if not remote_repo_name and remote_repo_autodetect == "1":
        try:
            bb.debug(2, 'No remote name is defined and KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_AUTODETECT is set. bitbake detects remote name from kernel-src')
            stdout, _ = bb.process.run('git remote', cwd=kernel_path, shell=True)
            remote_repo_name = stdout.splitlines()[0]
        except bb.process.ExecutionError as e:
            bb.warn("Failed to detect remote name. bitbake assumes that remote is 'origin'. Please consider setting KERNEL_CVE_CHECK_LINUX_GIT_REMOTE_REPO")

    cert_path = requests.certs.where()
    cmd = f'SSL_CERT_FILE={cert_path} python3 {cip_kernel_sec_path}/scripts/report_affected.py {opt_ignore} --remote-name {remote_target}:{remote_repo_name} --git-repo {kernel_path} {linux_cip_ver}'
    output = runfetchcmd(cmd, d, workdir=cip_kernel_sec_path)
    affect_cves = output.split(":")[2].strip().split()
    
    if len(affect_cves) > 0:
        bb.warn(output)

    whitelist = []
    for cve in get_issue_list(cip_kernel_sec_path):
        if cve not in affect_cves:
            whitelist.append(cve)

    bb.debug(2, 'Whitelisted by cip-kernel-sec:\n    {"\n    ".join(whitelist)}')
    d.appendVar('CVE_CHECK_WHITELIST', ' ' + ' '.join(whitelist))

    return affect_cves

def kernel_cve_check_merge_affected_cves_and_whitelist(d, cves):
    whitelist = d.getVar('CVE_CHECK_WHITELIST')

    triaged_cves = []
    for cve in cves:
        if not cve in whitelist: 
            triaged_cves.append(cve)

    return triaged_cves

def kernel_cve_check_write_result(d, affected_cves):
    result_file = f'{d.getVar("CVE_CHECK_RESULT_DIR")}/{d.getVar("KERNEL_CVE_CHECK_RESULT_FILE")}'
    
    import json

    tmp = { 'cves': affected_cves }

    with open(result_file, 'w') as f:
        f.write(json.dumps(tmp))

python kernel_cve_check() {
    if kernel_cve_check_update_cip_kernel_sec(d):
        cves = kernel_cve_check_run(d)
        if len(cves) > 0:
            affected_cves = kernel_cve_check_merge_affected_cves_and_whitelist(d, cves)
            kernel_cve_check_write_result(d, affected_cves)
}

do_cve_check[postfuncs] += "${@bb.utils.contains('PN', d.getVar('KERNEL_PN'), 'kernel_cve_check', '', d)}"
do_cve_check[depends] += "${@bb.utils.contains('PN', d.getVar('KERNEL_PN'), d.getVar('KERNEL_CVE_CHECK_TASK_ORDER'), '', d)}"
