# 
# CVE check class
# Copyright (c) Cybertrust Japan Co., Ltd.
#
# Authors:
#  Masami Ichikawa <masami.ichikawa@miraclelinux.com>
#
# SPDX-License-Identifier: MIT
#

CVE_CHECK_TRIVY_VERSION ??= "0.37.3"
CVE_CHECK_TRIVY_SHA256SUM = "4a10870563e7db4bc6abfe1b74bf7f3921873ba9765d9169625419f8143cda90"
CVE_CHECK_TRIVY_FORMAT ??= "cyclonedx"
CVE_CHECK_TRIVY_OUTPUT_FILE ??= "cve_check_cyclonedx-scan-log.json"

KERNEL_PN ??= "linux-cip"

# trivy release file checksum.
SRC_URI[sha256sum] = "${CVE_CHECK_TRIVY_SHA256SUM}"

def cve_check_download_trivy(d):
    import os

    dldir = d.getVar('DL_DIR')
    unpack_dir = f'{dldir}/trivy'

    d.setVar('CVE_CHECK_TRIVY_BIN_PATH', f'{unpack_dir}/trivy')

    if os.path.exists(unpack_dir):
        return True

    import subprocess

    trivy = f'trivy_{d.getVar("CVE_CHECK_TRIVY_VERSION")}_Linux-64bit.tar.gz'
    url = f'https://github.com/aquasecurity/trivy/releases/download/v{d.getVar("CVE_CHECK_TRIVY_VERSION")}/{trivy}'

    try:
        bb.plain('Downloading trivy ...')
        fetcher = bb.fetch2.Fetch([url], d)
        fetcher.download()
    except bb.fetch2.BBFetchException as e:
        bb.error('Failed to fetch trivy')
        return False

    os.mkdir(unpack_dir)

    cmd = [ 'tar', 'xf', f'{dldir}/{trivy}', '-C', unpack_dir ]
    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        proc.wait()
    
        retcode = int(proc.returncode)
        if not retcode == 0:
            bb.error('Failed to unpack trivy')
            return False

    return True

def cve_check_run_trivy(d):
    import subprocess

    rootfs = f'{d.getVar("WORKDIR")}/rootfs'
    
    output_path = f'{d.getVar("CVE_CHECK_RESULT_DIR")}/{d.getVar("CVE_CHECK_TRIVY_OUTPUT_FILE")}'

    cmd = [ d.getVar('CVE_CHECK_TRIVY_BIN_PATH'), 'fs', rootfs, '-f', d.getVar('CVE_CHECK_TRIVY_FORMAT'), '--scanners', 'vuln', '-o', output_path ]

    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        proc.wait()
    
        retcode = int(proc.returncode)
        if not retcode == 0:
            bb.error('Failed to run trivy')
            return False

    return True

def cve_check_report_cves(d):
    cve_file = f'{d.getVar("CVE_CHECK_RESULT_DIR")}/{d.getVar("CVE_CHECK_TRIVY_OUTPUT_FILE")}'

    import json
    import re

    with open(cve_file) as f:
        data = json.load(f)

    for cve in data['vulnerabilities']:
        id = cve['id']
        pkgs = []
        for affect in cve['affects']:
            ref = affect['ref']
            tmp = re.search(r'(\w+:\w+/\w+/)(\w+)(@\w*)', ref)
            if not tmp is None:
                pkgs.append(tmp.groups()[1])
                version = affect['versions'][0]['version']
        
        if len(pkgs) > 0:
            msg = f'CVE ({id}) is found in version {version} of {" ".join(pkgs)}'
            bb.warn(msg)
   
python do_cve_check() {
    import os
    result_dir = f'{d.getVar("DEPLOY_DIR")}/cve'

    if not os.path.exists(result_dir):
        os.mkdir(result_dir)

    d.setVar('CVE_CHECK_RESULT_DIR', result_dir)

    # skip this cve-check if recipe is linux kernel
    if d.getVar('PN') == d.getVar('KERNEL_PN'):
        return

    if cve_check_download_trivy(d):
        if cve_check_run_trivy(d):
            cve_check_report_cves(d)
}

addtask cve_check after do_rootfs
