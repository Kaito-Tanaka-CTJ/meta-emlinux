# 
# CVE check class
# Copyright (c) Cybertrust Japan Co., Ltd.
#
# Authors:
#  Masami Ichikawa <masami.ichikawa@miraclelinux.com>
#
# SPDX-License-Identifier: MIT
#

EMLINUX_CVE_CHECK_TOOL_VERSION ??= "0.37.3"
EMLINUX_CVE_CHECK_TOOL_SHA256SUM = "4a10870563e7db4bc6abfe1b74bf7f3921873ba9765d9169625419f8143cda90"
EMLINUX_CVE_CHECK_TOOL_FORMAT ??= "cyclonedx"
EMLINUX_CVE_CHECK_TOOL_OUTPUT_FILE ??= "cve_check_cyclonedx-scan-log.json"

KERNEL_PN ??= "linux-cip"

# release file checksum.
SRC_URI[sha256sum] = "${EMLINUX_CVE_CHECK_TOOL_SHA256SUM}"

def cve_check_download_tool(d):
    import os

    dldir = d.getVar('DL_DIR')
    unpack_dir = f'{dldir}/cvecheck'

    d.setVar('EMLINUX_CVE_CHECK_TOOL_BIN_PATH', f'{unpack_dir}/trivy')

    if os.path.exists(unpack_dir):
        return True

    import subprocess

    tool_name = f'trivy_{d.getVar("EMLINUX_CVE_CHECK_TOOL_VERSION")}_Linux-64bit.tar.gz'
    url = f'https://github.com/aquasecurity/trivy/releases/download/v{d.getVar("EMLINUX_CVE_CHECK_TOOL_VERSION")}/{tool_name}'

    try:
        bb.plain('Downloading cve check tool ...')
        fetcher = bb.fetch2.Fetch([url], d)
        fetcher.download()
    except bb.fetch2.BBFetchException as e:
        bb.error('Failed to fetch cve check tool')
        return False

    os.makedirs(unpack_dir)

    cmd = [ 'tar', 'xf', f'{dldir}/{tool_name}', '-C', unpack_dir ]
    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        proc.wait()
    
        retcode = int(proc.returncode)
        if not retcode == 0:
            bb.error('Failed to unpack cve check tool')
            return False

    return True

def cve_check_run_tool(d):
    import subprocess

    rootfs = f'{d.getVar("WORKDIR")}/rootfs'
    
    output_path = f'{d.getVar("CVE_CHECK_RESULT_DIR")}/{d.getVar("EMLINUX_CVE_CHECK_TOOL_OUTPUT_FILE")}'

    cmd = [ d.getVar('EMLINUX_CVE_CHECK_TOOL_BIN_PATH'), 'fs', rootfs, '-f', d.getVar('EMLINUX_CVE_CHECK_TOOL_FORMAT'), '--scanners', 'vuln', '-o', output_path ]

    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        proc.wait()
    
        retcode = int(proc.returncode)
        if not retcode == 0:
            bb.error('Failed to run cve check tool')
            return False

    return True

def cve_check_report_cves(d):
    cve_file = f'{d.getVar("CVE_CHECK_RESULT_DIR")}/{d.getVar("EMLINUX_CVE_CHECK_TOOL_OUTPUT_FILE")}'

    import json
    import re

    with open(cve_file) as f:
        data = json.load(f)

    for cve in data['vulnerabilities']:
        id = cve['id']
        pkgs = []
        for affect in cve['affects']:
            ref = affect['ref']
            tmp = re.search(r'(\w+:\w+/\w+/)(\w+)(@\w*)', ref)
            if not tmp is None:
                pkgs.append(tmp.groups()[1])
                version = affect['versions'][0]['version']
        
        if len(pkgs) > 0:
            msg = f'CVE ({id}) is found in version {version} of {" ".join(pkgs)}'
            bb.warn(msg)
   
python do_cve_check() {
    import os
    result_dir = f'{d.getVar("DEPLOY_DIR")}/cve'

    if not os.path.exists(result_dir):
        os.makedirs(result_dir)

    d.setVar('CVE_CHECK_RESULT_DIR', result_dir)

    # skip this cve-check if recipe is linux kernel
    if d.getVar('PN') == d.getVar('KERNEL_PN'):
        return

    if cve_check_download_tool(d):
        if cve_check_run_tool(d):
            cve_check_report_cves(d)
}

do_cve_check[network] = "${TASK_USE_NETWORK}"
addtask cve_check after do_rootfs
